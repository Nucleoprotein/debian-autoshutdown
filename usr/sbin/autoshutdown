#!/bin/bash
#==============================================================================
#
#          FILE:    autoshutdown
#   DESCRIPTION:    Shuts-down a PC/Server - variable options
#  REQUIREMENTS:    Debian / Ubuntu-based system
#          BUGS:    If you find any: https://github.com/OpenMediaVault-Plugin-Developers/openmediavault-autoshutdown
#        AUTHOR:    Solo0815 - R. Lindlein (Ubuntu-Port, OMV-Changes), it should work on any Debain-based System, too
#                   based on autoshutdown.sh v0.7.008 by chrikai, see:
#                   https://sourceforge.net/apps/phpbb/freenas/viewtopic.php?f=12&t=2158&start=60
#
#==============================================================================

set -euo pipefail

######## VARIABLE DEFINITION ########
# Variables that normal users should normally not define - PowerUsers can do it here or add it to the config.
LPREPEAT=5                  # Number of test cycles for finding and active LOADPROCNAMES-Process (default=5).
TPREPEAT=5                  # Number of test cycles for finding and active TEMPPROCNAMES-Process (default=5).

############## LOGGING ##############
FACILITY="local6"           # Facility to log to -> see rsyslog.conf.
DEBUG="false"               # Default debug logging mode is enabled.
VERBOSE="false"             # Default if verbose logging mode is enabled.
SYSLOG="false"              # Default if logging should go to syslog.

FAKE="false"                # Default fake mode operation.

######## STORAGE DEFINITION #########
declare -A NIC_TO_IP        # Associative array for storing _check_networkconfig network interface to IP address mappings.
declare -A PINGLIST_IFACE   # Associative array for storing _ping_range network interface IP addresses.
declare -A P_HDDIO_DEVS     # Associative array for storing _check_hddio read, wrtn and epoch values.
declare -A P_UL_DL_RATE     # Associative array for storing _check_ul_dl_rate a network interface tx, rx and epoch values.

######## CONSTANT DEFINITION ########
readonly CONFIG="${1:-/etc/autoshutdown.conf}"            # Autoshutdown configuration options.
readonly DEFAULT_CONFIG="${2:-/etc/autoshutdown.default}" # Autoshutdown default configuration options.

######## FUNCTION DECLARATION ########

###############################################################################
#
#   Name          : _log
#   Parameters    : $1 : Log message in format "PRIORITY: MESSAGE".
#                 : $2 : 'force' will force logging to syslog and sent to
#                        stderr.
#   Globals       : $FAKE    : Are we runnig in fake mode. ('true' or 'false')
#                 : $VERBOSE : Set verbose logging. ('true' or 'false')
#                 : $SYSLOG  : Should logging to to syslog. ('true' or 'false')
#   Return        : 0 on success.
#
_log()
{
    [[ "${1}" =~ ^([A-Za-z]*):\ *(.*) ]] && {
       local priority=${BASH_REMATCH[1]}
       local message="${FUNCNAME[1]}(): ${BASH_REMATCH[2]}"
    }
    [ "${FAKE}" == "true" ] && message="FAKE-Mode: ${message}"
    message="$(basename "${0}")[$$]: ${priority}: '${message}'"

    [[ "${VERBOSE}" == "true" || "${FAKE}" == "true" ]] &&
        echo "$(date '+%b %e %H:%M:%S') ${USER}: ${message}"

    local stderr=""
    [ "${2:-}" == "force" ] && stderr="--stderr"
    [[ "${SYSLOG}" == "true" || "${2:-}" == "force" ]] &&
       logger "${stderr}" -p "${FACILITY}.${priority,,}" "${message}"

    return 0
}


###############################################################################
#
#   Name          : _ping_range
#   Parameters    : $1 : The network interface that is being worked on.
#                 : $2 : The network interface IP address.
#                 : $3 : IP addresses found for all network interfaces.
#   Globals       : $PINTLIST       : A file reference of IPs to be checked
#                                     (expert setting).
#                 : $RANGE          : Details of IPs to be checked.
#                 : $PINGLIST_IFACE : Associative array for storing network
#                                     interface IP addresses.
#   Return        : Number of active IP on network interfaces.
#
_ping_range()
{
    local -r net_iface="${1}"
    local -r server_ip="${2}"
    local -r server_ips="${3// /\\|}"

    local ip_list=()
    local pinglist_array=()
    local -r empty="No IP addresses specified"

    if [ "${DEBUG}" == "true" ]; then
        _log "DEBUG: INTERFACE: ${net_iface}"
        _log "DEBUG: CLASS: ${server_ip%.*}"
        _log "DEBUG: PINGLIST: ${PINGLIST:-N/A}"
        _log "DEBUG: RANGE: ${RANGE:-N/A}"
    fi

    local key="${PINGLIST:-"${net_iface}"}"
    if [ -z "${PINGLIST_IFACE["${key}"]:-}" ]; then
        if [ "${DEBUG}" == "true" ]; then
            _log "DEBUG: Generating new PINGLIST_IFACE[${key}]"
        fi

        if [ -n "${PINGLIST:-}" ]; then
            mapfile -t ip_list < "${PINGLIST}"
        else
            for rg in ${RANGE//,/ }; do
                if [[ "${rg}" =~ ^([a-z]+[0-9]+)[:] &&
                        "${BASH_REMATCH[1]}" != "${net_iface}" ]]; then
                    continue
                elif [[ "${rg}" =~ ^([a-z]+[0-9]+[:])?(([0-9]{1,3}\.){3})?([1-9][0-9]{0,2})$ ]]; then
                    mapfile -t -O "${#ip_list[@]}" ip_list <<< \
                        "${BASH_REMATCH[2]:-"${server_ip%.*}."}${BASH_REMATCH[4]}"
                elif [[ "${rg}" =~ ^([a-z]+[0-9]+[:])?(([0-9]{1,3}\.){3})?([1-9][0-9]{0,2})\.{2}([1-9][0-9]{0,2})$ ]]; then
                    local min="${BASH_REMATCH[4]}"; local max="${BASH_REMATCH[5]}"
                    if [ "${BASH_REMATCH[5]}" -lt "${BASH_REMATCH[4]}" ]; then
                        min="${BASH_REMATCH[5]}"; max="${BASH_REMATCH[4]}"
                    fi
                    mapfile -t -O "${#ip_list[@]}" ip_list < <(
                        seq --format "${BASH_REMATCH[2]:-"${server_ip%.*}."}%g" \
                            "${min}" "${max}")
                fi
            done
        fi
        PINGLIST_IFACE["${key}"]="$(
            printf '%s\n' "${ip_list[@]}" |
            sort -t . -k 3,3n -k 4,4n | uniq |
            grep -v "${server_ips}")"
    fi
    mapfile -t pinglist_array <<< "${PINGLIST_IFACE["${key}"]:-${empty}}"

    if [ "${DEBUG}" == "true" ]; then
        _log "DEBUG: pinglist_array: ${pinglist_array[*]:-"${empty}"}"
    fi

    if [[ "${pinglist_array[0]}" == "${empty}" ]]; then
        _log "INFO: No IP addresses specified for: ${net_iface} -> next check"
        return 0
    fi

    _log "INFO: Retrieve list of active IPs for: ${net_iface}"
    local fping_result
    fping_result="$(fping --iface="${net_iface}" --quiet --alive --retry=1 \
                        "${pinglist_array[@]}" || true)"

    if [ -z "${fping_result}" ]; then
        _log "INFO: No active IPs found in the specified range -> next check"
        return 0
    fi

    while read -r active_ip; do
        _log "INFO: ${active_ip} is active"
    done < <(sort -t . -k 3,3n -k 4,4n <<< "${fping_result}")

    _log "INFO: Active IPs found in the specified range -> no shutdown"

    return "$(wc -l <<< "${fping_result}")"
}


###############################################################################
#
#   Name          : _shutdown
#   Parameters    : None
#   Globals       : $SHUTDOWNCOMMAND : The shutdown command to use as defined
#                                      by the config option.
#   Return        : None, script exit point.
#
_shutdown()
{
    # We've had no responses for the required number of consecutive scans
    # defined in CYCLES shutdown & power off.

    if [ -z "${SHUTDOWNCOMMAND}" ]; then
        _log "WARNING: No shutdown command set."
        _log "WARNING: Setting it to: ${DEFAULT_SHUTDOWNCOMMAND}"
        SHUTDOWNCOMMAND="${DEFAULT_SHUTDOWNCOMMAND}"
    fi

    # When FAKE-Mode is on.
    [ "${FAKE}" == "true" ] && {
        _log "INFO: Fake-shutdown issued: '${SHUTDOWNCOMMAND}' - Command is not executed because of Fake-Mode" force
        _log "INFO: Autoshutdown will end here"
        _log "INFO:"
        exit 0; }

    # Without Fake-Mode.
    _log "INFO: Shutdown issued: '${SHUTDOWNCOMMAND}'" force
    _log "INFO:"

    # Write everything to disk/stick and shutdown, hibernate, or whatever is
    # configured.
    if sync; then eval "${SHUTDOWNCOMMAND}" && exit 0; fi
    # Sleep 5 minutes to allow the /etc/init.d/autoshutdown to kill the script
    # and give the right log-message. If we exit here immediately, there are
    # errors in the log.
    sleep 5m
    # We need this just for debugging - the system should be shutdown here.
    _log "INFO: 5 minutes are over" force
    sleep 5m
    _log "INFO: Another 5 minutes are over" force
    exit 1
}


###############################################################################
#
#   Name          : _check_processes
#   Parameters    : None
#   Globals       : $LOADPROCNAMES : Command names of processes with load
#                                    dependent children.
#                 : $TEMPPROCNAMES : Command names of processes only started
#                                    when active.
#   Return        : 0         : If no active process has been found.
#                 : 1 or more : If at least one active process has been found.
#
_check_processes()
{
    # Check for each given command name in LOADPROCNAMES if it is currently
    # stated active in "top". It has been found, that for smbd, proftpd, nsfd,
    # ... there are processes always present in "ps" or "top" output (This
    # could be due to the "daemon" mechanism.) So the only chance to identify
    # there is something happening with these processes, is to check if "top"
    # states them active hence the "-i" parameter is required.
    local num_load_proc=0
    for process in ${LOADPROCNAMES//,/ }; do
        local lp=0
        local l_proc=0
        for (( N=0; N < LPREPEAT; N++ )); do
            local lp_result; lp_result="$(
                top -i -b -d 1 -n 1 |
                    awk -v regex="^${process}$" -v count=0 \
                        '$NF ~ regex {count++} END{print count}')"
            lp=$(( lp | lp_result ))
            l_proc=$(( l_proc + lp_result ))
        done

        num_load_proc=$(( num_load_proc + lp ))

        if [ "${DEBUG}" == "true" ]; then
            _log "DEBUG: Load processes: ${process}: Found ${l_proc} active after ${LPREPEAT} cycles"
        fi
    done
    [ "${num_load_proc}" -gt 0 ] &&
        _log "INFO: Found ${num_load_proc} active from: ${LOADPROCNAMES}"

    # Check for each given command name in TEMPPROCNAMES if it is currently
    # stated present in "top". It has been found that for sshd, ... there are
    # processes only present in "ps" or "top" output when is is used. It is not
    # guaranteed, that top states these services active, as they usually wait
    # for user input no "-i" parameter on the command line, but shear presence
    # is enough.
    local num_temp_proc=0
    for process in ${TEMPPROCNAMES//,/ }; do
        local tp=0
        local t_proc=0
        for (( N=0; N < TPREPEAT; N++ )); do
            local tp_result; tp_result="$(
                top -b -d 1 -n 1 |
                    awk -v regex="^${process}$" -v count=0 \
                     '$NF ~ regex {count++} END{print count}')"

            # If there is no process with top, try "pgrep", but not in.tftpd.
            if [ "${tp_result}" -eq 0 ]; then
                if [ "${process}" != "in.tftpd" ]; then
                    tp_result="$(pgrep -fc "${process}")"
                else
                    if [ "${DEBUG}" == "true" ]; then
                        _log "DEBUG: Temp processes: Skipping 'in.tftpd'"
                        break
                    fi
                fi
            fi
            tp=$(( tp | tp_result ))
            t_proc=$(( t_proc + tp_result ))
        done

        num_temp_proc=$(( num_temp_proc + tp ))

        if [ "${DEBUG}" == "true" ]; then
            _log "DEBUG: Temp processes: ${process}: Found ${t_proc} active after ${TPREPEAT} cycles"
        fi
    done
    [ "${num_temp_proc}" -gt 0 ] &&
        _log "INFO: Found ${num_temp_proc} active from: ${TEMPPROCNAMES}"

    local active=$(( num_load_proc + num_temp_proc ))
    local msg="INFO: Found ${active} process(es) active -> "
    if [ "${active}" -eq 0 ]; then
        _log "${msg}next check"
    else
        _log "${msg}no shutdown"
    fi

    return "${active}"
}


###############################################################################
#
#   Name          : _check_plugin
#   Parameters    : None
#   Globals       : None
#   Return        : 0 : If file has not been found.
#                 : 1 : If file has been found.
#
# With this plugin-system everyone can check if a specific file exists.
# If it exists, the machine won't shutdown. You find sample plugins in:
# /etc/autoshutdown.d
#
_check_plugin()
{
    local foundvalue=0
    local rvalue=0

    for asd_plugin in /etc/autoshutdown.d/*; do

        local plugin_name
        plugin_name="${asd_plugin##*/}"
        local plugin_folder
        plugin_folder="$(awk -F= '/folder=/{gsub(/["]/,"",$2);print $2}' "${asd_plugin}")"
        local plugin_file
        plugin_file="$(awk -F= '/file=/{gsub(/["]/,"",$2);print $2}' "${asd_plugin}")"
        local plugin_content
        plugin_content="$(awk -F= '/content=/{gsub(/["]/,"",$2);print $2}' "${asd_plugin}")"

        if [ "${DEBUG}" == "true" ]; then
            _log "DEBUG: -----------------------------------------------------"
            _log "DEBUG: Plugin: ${plugin_name}: asd_plugin: ${asd_plugin}"
            _log "DEBUG: Plugin: ${plugin_name}: plugin_name: ${plugin_name}"
            _log "DEBUG: Plugin: ${plugin_name}: plugin_folder: ${plugin_folder}"
            _log "DEBUG: Plugin: ${plugin_name}: plugin_file: ${plugin_file}"
            if [ -n "${plugin_content}" ]; then
                _log "DEBUG: Plugin: ${plugin_name}: plugin_content: ${plugin_content}"
            fi
        fi

        # When file exists (matches regex), no shutdown.
        if [ -z "$(find "${plugin_folder}" -regextype posix-egrep -regex ".*${plugin_file}" 2>/dev/null)" ]; then
            _log "INFO: Plugin: ${plugin_name}: File not found"
            continue
        fi

        # Check, if plugin_content for the plugin is defined.
        if [ -z "${plugin_content}" ]; then
            # Content not defined and file found.
            _log "INFO: Plugin: ${plugin_name}: File found -> no shutdown"
            (( foundvalue+=1 ))
        elif grep -q "${plugin_content}" "${plugin_folder}/${plugin_file}"; then
            _log "INFO: Plugin: ${plugin_name}: Content found (${plugin_content}) -> no shutdown"
            (( foundvalue+=1 ))
        else
            # Content not found.
            _log "INFO: Plugin: ${plugin_name}: Content not found (${plugin_content}) -> next check"
        fi
    done

    if [ "${DEBUG}" == "true" ]; then
        _log "DEBUG: -----------------------------------------------------"
        _log "DEBUG: All plugins processed: Active plugins found: ${foundvalue}"
    fi

    if [ "${foundvalue}" -gt 0 ]; then
        rvalue=1
    fi

    if [ "${DEBUG}" == "true" ]; then
        _log "DEBUG: After all plugin-checks: rvalue: ${rvalue}"
    fi

    return ${rvalue}
}


###############################################################################
#
#   Name          : _check_loadaverage
#   Parameters    : None
#   Globals       : $LOADAVERAGE : Integer load average.
#   Return        : 1 : If load average is higher (greater) than LOADAVERAGE,
#                       no shutdown.
#                 : 0 : If load average is lower (less) than LOADAVERAGE.
#
# This script checks if the load average is higher than LOADAVERAGE over the
# last 1 minute.
# If yes -> no shutdown, next cycle.
# If no  -> next check and shutdown if all cycles failed.
#
_check_loadaverage()
{
    local rvalue=0
    # Get the load averages.
    local current_load_average_line
    current_load_average_line="$(LC_ALL=C cat "/proc/loadavg")"
    # Get load average in decimal notation.
    local current_load_average_decimal
    current_load_average_decimal="$(awk '{print $1}' <<< "${current_load_average_line}")"
    # Convert to integer value by removing decimal point and assuming two fixed decimal places.
    local current_load_average
    current_load_average="$(sed 's/[.]//;s/^0*//g;s/^$/0/' <<< "${current_load_average_decimal}")"

    if [ "${DEBUG}" == "true" ]; then
        _log "DEBUG: -----------------------------------------------------"
        _log "DEBUG: Output from '/proc/loadavg': ${current_load_average_line}"
        _log "DEBUG: current_load_average_decimal: ${current_load_average_decimal}"
        _log "DEBUG: current_load_average: ${current_load_average}"
    fi

    local msg="INFO: Load average (${current_load_average_decimal} -> ${current_load_average}) is"
    if [ "${current_load_average}" -gt "${LOADAVERAGE}" ]; then
        msg+=" higher than target (${LOADAVERAGE}) -> no shutdown"
        rvalue=1
    else
        msg+=" lower than target (${LOADAVERAGE}) -> next check"
    fi
    _log "${msg}"

    if [ "${DEBUG}" == "true" ]; then _log "DEBUG: rvalue: ${rvalue}"; fi

    return "${rvalue}"
}


###############################################################################
#
#   Name          : _check_net_status
#   Parameters    : $1 : Network interface under test.
#                 : $2 : The network interface IP address.
#   Globals       : $NSOCKETNUMBERS    : Socket number to check for activity.
#                 : $NSOCKETIGNORESELF : If set will ignore the Network
#                                        interface IP address as a connection.
#                 : $DEFAULT_NSOCKETIGNORESELF : Default for NSOCKETIGNORESELF.
#   Return        : 0         : If no active socket has been found, ready for
#                               shutdown.
#                 : 1 or more : If at least one active socket has been found,
#                               no shutdown.
#
_check_net_status()
{
    local -r net_iface="${1}"
    local -r server_ip="${2}"

    local active=0
    local -r empty="Found no active connections"

    _log "INFO: Check Connections for: ${net_iface}"

    # Check for each given socket number in NSOCKETNUMBERS to see if it is
    # currently stated active in the ss command.
    for nsocket in ${NSOCKETNUMBERS//,/ }; do
        local lines; lines="$(LC_ALL=C
            ss -n |
            awk -v regex="^([[]::ffff:)?${server_ip}[]]?:${nsocket}$" \
                -v ignore_self="${NSOCKETIGNORESELF:-"${DEFAULT_NSOCKETIGNORESELF}"}" \
                -v server_ip="${server_ip}" \
                '(ignore_self == "false") ? $2 ~ /^ESTAB$/ && $5 ~ regex : $2 ~ /^ESTAB$/ && $5 ~ regex && $6 !~ server_ip')"

        if [ "${DEBUG}" == "true" ]; then
            _log "DEBUG: Port ${nsocket}: ${lines:-"${empty}"}"
        fi

        # No active connection found.
        [ -z "${lines}" ] && continue

        local no_lines; no_lines="$(wc -l <<< "${lines}")"
        (( active+="${no_lines}" ))

        local conips; conips="$(
            awk '{gsub(/^([[]::ffff:)?/,"",$6);
                  gsub(/[]]?:[0-9]+$/,"",$6); print $6}' <<< "${lines}" |
            sort -t . -k 3,3n -k 4,4n | uniq)"

        # Set portprotocol - Only default ports are defined here.
        local portprotocol
        case "${nsocket}" in
            80|8080) portprotocol="HTTP" ;;
            22)      portprotocol="SSH" ;;
            21)      portprotocol="FTP" ;;
            139|445) portprotocol="SMB/CIFS" ;;
            443)     portprotocol="HTTPS" ;;
            548)     portprotocol="AFP" ;;
            873)     portprotocol="RSYNC" ;;
            3306)    portprotocol="MYSQL" ;;
            3689)    portprotocol="DAAP" ;;
            6991)    portprotocol="BITTORRENT" ;;
            9091)    portprotocol="BITTORRENT_WEBIF" ;;
            32400)   portprotocol="PLEXMEDIASERVER" ;;
            49152)   portprotocol="UPNP" ;;
            51413)   portprotocol="BITTORRENT" ;;
            *)       portprotocol="unknown" ;;
        esac

        _log "INFO: Found ${no_lines} active connection on port ${nsocket} ($portprotocol) from: ${conips//$'\n'/, }"
    done

    _log "INFO: Found ${active} active socket(s) on ${net_iface}, from port(s): ${NSOCKETNUMBERS}"

    # Return the number of active sockets found.
    return "${active}"
}


###############################################################################
#
#   Name          : _check_docker_status
#   Parameters    : None
#   Globals       : $NSOCKETNUMBERS : Socket number to check for activity.
#   Return        : 0         : If no active socket has been found, ready for
#                               shutdown.
#                 : 1 or more : If at least one active socket has been found,
#                               no shutdown.
#
_check_docker_status()
{
    command -v docker &>/dev/null || return 0
    local active=0
    for container in $(docker ps --format "{{ .Names }}"); do
        local details; read -ra details <<< "$(LC_ALL=C docker inspect --format \
            '{{ .State.Pid }} {{ .NetworkSettings.IPAddress }}
             {{- ""}} {{ range $key, $value := .NetworkSettings.Ports }}
                {{- ""}}{{ range . }}{{ .HostPort }}:{{ index (split $key "/") 0 }}
                {{- ""}}{{ end }}
             {{- ""}} {{ end }}' \
            "${container}")"
        [[ "${#details[@]}" -eq 0 || ! ("${details[*]}" =~ :) ]] && continue
        local port_map=()
        local nsocketnumbers
        mapfile -t nsocketnumbers <<< "${NSOCKETNUMBERS//,/$'\n'}"
        for ports in "${details[@]: -2}"; do
            if [[ "${ports}" =~ (.*)-(.*):(.*)-(.*) ]]; then
                local host_map
                mapfile -t host_map < <(seq "${BASH_REMATCH[1]}" "${BASH_REMATCH[2]}")
                local con_map
                mapfile -t con_map < <(seq "${BASH_REMATCH[3]}" "${BASH_REMATCH[4]}")
                for index in "${!host_map[@]}"; do
                    [[ " ${nsocketnumbers[*]} " =~ \ ${host_map["${index}"]}\  ]] &&
                        port_map["${host_map["${index}"]}"]="${con_map["${index}"]}"
                done
                continue
            fi
            [[ " ${nsocketnumbers[*]} " =~ \ ${ports%:*}\  ]] &&
                port_map["${ports%:*}"]="${ports#*:}"
        done
        [ "${#port_map[@]}" -eq 0 ] && continue
        for target in "${!port_map[@]}"; do
            local lines; lines="$(LC_ALL=C
                nsenter -t "${details[0]}" -n ss -n |
                awk -v \
                    regex="^([[]::ffff:)?${details[1]}[]]?:${port_map[${target}]}$" \
                    '$2 ~ /^ESTAB$/ && $5 ~ regex' ||
                true)"
            local con_ips; con_ips="$(
                awk '{gsub(/^([[]::ffff:)?/,"",$6);
                      gsub(/[]]?:[0-9]+$/,"",$6);
                      print $6}' <<< "${lines}" |
                sort -t . -k 3,3n -k 4,4n | uniq)"
            [ -n "${lines}" ] &&
                { local no_lines; no_lines="$(wc -l <<< "${lines}")"
                  (( active+="${no_lines}" ))
                  _log "INFO: Found ${no_lines} active connection on port ${target} (${container}) from: ${con_ips//$'\n'/, }"; }
        done
    done
    _log "INFO: Found ${active} active socket(s), from port(s): ${NSOCKETNUMBERS}"
    return "${active}"
}


###############################################################################
#
#   Name          : _check_users_cli_status
#   Parameters    : None
#   Globals       : None
#   Return        : 0 : If there are no connected users, ready for shutdown.
#                 : 1 : If there are connected users, no shutdown.
#
_check_users_cli_status()
{
    local users_connected; users_connected="$(LC_ALL=C w -hs)"

    if [ -z "${users_connected}" ]; then
        _log "INFO: There are no users connected -> next check"
        return 0
    fi

    if [ "${DEBUG}" == "true" ]; then
        _log "DEBUG: Connected users:"
        while read -r user; do
            _log "DEBUG: ${user}"
        done <<< "${users_connected}"
    fi

    while read -r connecton; do
        local connected_user; connected_user="$(
            awk '{print $1}' <<< "${connecton}")"
        local connecton_from; connecton_from="$(
            awk '{gsub(/^-$/,"localhost",$3);
                  print $2 " " $3}' <<< "${connecton}" )"
        _log "INFO: User: ${connected_user} on from ${connecton_from}"
    done <<< "${users_connected}"

    _log "INFO: There are users connected -> no shutdown"
    return 1
}


###############################################################################
#
#   Name          : _check_smb_status
#   Parameters    : None
#   Globals       : None
#   Return        : 0 : If there are no smb client connected, ready for
#                       shutdown.
#                 : 1 : If there are smb client connected, no shutdown.
#
_check_smb_status()
{
    local smb_connectons
    smb_connectons="$(LC_ALL=C smbstatus --brief | awk 'NR>4')"
    local smb_lock_pids
    mapfile -t smb_lock_pids <<< "$(
        LC_ALL=C smbstatus --locks |
        awk '$1 ~ /[0-9]+/{print $1}' |
        sort -u)"

    [[ -z "${smb_connectons}" || ! "${smb_lock_pids[*]}" ]] && {
        _log "INFO: No SMB clients connected with locks -> next check"
        return 0; }

    while read -r pid user host proto; do
        [[ " ${smb_lock_pids[*]} " =~ \ ${pid}\  ]] &&
            _log "INFO: SMB client with locks - PID: ${pid} USER: ${user} HOST: ${host} PROTO: ${proto}"
    done < <(awk '{print $1 " " $2":"$3 " " $4 " " $6}' <<< "${smb_connectons}")

    _log "INFO: SMB clients with locks connected -> no shutdown"
    return 1
}


###############################################################################
#
#   Name          : _check_ul_dl_rate
#   Parameters    : $1 : The network interface to check.
#   Globals       : $ULDLRATE     : Rate in kB/s of network activity.
#                 : $P_UL_DL_RATE : Associative array for strong a network
#                                   interface tx, rx and epoch values.
#   Return        : 0 : If not enough network activity, ready for shutdown.
#                 : 1 : If enough network activity, no shutdown.
#
# Checks for activity on given network interface It compares the RX and TX
# bytes in every cycle to detect if they significantly changed. If they
# haven't, it will force the system to sleep or do the next check.
#
_check_ul_dl_rate()
{
    local -r net_iface="${1}"

    _log "INFO: Running on interface: ${net_iface}"

    local epoch_sec="${EPOCHSECONDS}"
    local last_checked_sec=$((epoch_sec - ${P_UL_DL_RATE["${net_iface}_epoch_sec"]:-${epoch_sec}}))

    local rx_kb
    rx_kb="$(awk '{printf("%.0f",($0/1024))}' \
                "/sys/class/net/${net_iface}/statistics/rx_bytes")"
    local tx_kb
    tx_kb="$(awk '{printf("%.0f",($0/1024))}' \
                "/sys/class/net/${net_iface}/statistics/tx_bytes")"

    if [ "${DEBUG}" == "true" ]; then
        _log "DEBUG: Actual: TX kB: ${tx_kb}, RX kB: ${rx_kb}"
    fi

    if [[ "${last_checked_sec}" -eq 0 ||
          -z "${P_UL_DL_RATE["${net_iface}_epoch_sec"]:-}" ||
          -z "${P_UL_DL_RATE["${net_iface}_tx"]:-}" ||
          -z "${P_UL_DL_RATE["${net_iface}_rx"]:-}" ]]; then
        # Store current value.
        P_UL_DL_RATE["${net_iface}_epoch_sec"]="${epoch_sec}"
        P_UL_DL_RATE["${net_iface}_rx"]="${rx_kb}"
        P_UL_DL_RATE["${net_iface}_tx"]="${tx_kb}"

        if [ "${DEBUG}" == "true" ]; then
            _log "DEBUG: Store new TX, RX and epoch values"
        fi
        return 0
    fi

    if [ "${DEBUG}" == "true" ]; then
        _log "DEBUG: Previous TX kB: ${P_UL_DL_RATE["${net_iface}_tx"]}, RX kB: ${P_UL_DL_RATE["${net_iface}_rx"]}"
    fi

    # Calculate threshold limit (defined kB/s multiplied with second since
    # last checked) to get the total value of kB over the 'last checked
    # time' - 'time now'.
    local ul_dl_increase=$((ULDLRATE * last_checked_sec))

    # Calculate the total value.
    local t_rx=$((P_UL_DL_RATE["${net_iface}_rx"] + ul_dl_increase))
    local t_tx=$((P_UL_DL_RATE["${net_iface}_tx"] + ul_dl_increase))

    # Calculate difference between the last and the actual value.
    local diff_rx=$((rx_kb - P_UL_DL_RATE["${net_iface}_rx"]))
    local diff_tx=$((tx_kb - P_UL_DL_RATE["${net_iface}_tx"]))

    # Calculate dl/ul-rate in kB/s - format xx.x.
    local last_dl_rate
    last_dl_rate=$(awk '{printf("%.1f",($1/$2))}' <<< "${diff_rx} ${last_checked_sec}")
    local last_ul_rate
    last_ul_rate=$(awk '{printf("%.1f",($1/$2))}' <<< "${diff_tx} ${last_checked_sec}")

    if [ "${DEBUG}" == "true" ]; then
        _log "DEBUG: last_checked_sec ${last_checked_sec}"
        _log "DEBUG: ul_dl_increase: ${ul_dl_increase}"
        _log "DEBUG: t_rx: ${t_rx}"
        _log "DEBUG: diff_rx: ${diff_rx}"
        _log "DEBUG: t_tx: ${t_tx}"
        _log "DEBUG: diff_tx: ${diff_tx}"
        _log "DEBUG: Check: rx_kb:${rx_kb} <= t_rx:${t_rx}"
        _log "DEBUG: Check: tx_kb:${tx_kb} <= t_tx:${t_tx}"
    fi

    # Store current value.
    P_UL_DL_RATE["${net_iface}_epoch_sec"]="${epoch_sec}"
    P_UL_DL_RATE["${net_iface}_rx"]="${rx_kb}"
    P_UL_DL_RATE["${net_iface}_tx"]="${tx_kb}"

    local msg="INFO: Network interface: ${net_iface} (last ${last_checked_sec}s) "
          msg+="DL: ${last_dl_rate} kB/s, "
          msg+="UL: ${last_ul_rate} kB/s"

    if [[ "${rx_kb}" -gt "${t_rx}" ||
          "${tx_kb}" -gt "${t_tx}" ]]; then
        _log "${msg} over ${ULDLRATE} kB/s -> no shutdown"
        return 1
    fi

    _log "${msg} under ${ULDLRATE} kB/s -> next check"
    return 0
}


###############################################################################
#
#   Name          : _check_clock
#   Parameters    : None
#   Globals       : $UPHOURS : Range of hours, where system should go to sleep,
#                              e.g. 06:00..20:00.
#   Return        : 0 : If actual value of hours is in DOWN range, ready for
#                       shutdown.
#                 : 1 : If actual value of hours is in UP range, sleep till
#                       DOWN range, block shutdown.
#
_check_clock()
{
    local -r range_start="$(date -f - "+%R" <<< "${UPHOURS%..*}")"
    local -r range_end="$(date -f - "+%R" <<< "${UPHOURS#*..}")"

    local -r epoch_sec="${EPOCHSECONDS}"
    local -r current_time="$(date -d @"${epoch_sec}" +%R)"

    local epoch_start; epoch_start="$(date -f - +%s <<< \
            "$(date -d @"$((epoch_sec))" +%D) ${range_start}")"
    local epoch_end; epoch_end="$(date -f - +%s <<< \
            "$(date -d @"$((epoch_sec))" +%D) ${range_end}")"
    # Fix epoch if we are wrapped around midnight applying a lexicographic
    # comparison.
    if [[ "${range_start}" > "${range_end}" ]]; then
        if [[ "${current_time}" > "${range_start}" ||
              "${current_time}" == "${range_start}" ||
              "${current_time}" > "${range_end}" ||
              "${current_time}" == "${range_end}" ]]; then
            epoch_end="$(date -f - +%s <<< \
                "$(date -d @"$((epoch_sec + 86400))" +%D) ${range_end}")"
        else
            epoch_start="$(date -f - +%s <<< \
                "$(date -d @"$((epoch_sec - 86400))" +%D) ${range_start}")"
        fi
    fi

    # If it negative or zero we already in the shutdown window.
    local seconds_to_sleep="$((epoch_end - epoch_sec))"
    local msg; msg="DEBUG: Current time: $(date -d @"${epoch_sec}"), "
          msg+="Stay up range - start: ${range_start}, end: ${range_end} -> "
    if [[ "${epoch_sec}" -lt "${epoch_start}" ||
          "${epoch_sec}" -ge "${epoch_end}" ||
          "${seconds_to_sleep}" -le 0 ]]; then
        if [ "${DEBUG}" == "true" ]; then _log "${msg}allow shutdown"; fi
       _log "INFO: System is in shutdown range -> next check"
       return 0
    fi

    if [ "${DEBUG}" == "true" ]; then _log "${msg}stay up"; fi
    _log "INFO: System is in stay up range"
    _log "INFO: Sleeping until: $(
            date -d @"$((epoch_sec + seconds_to_sleep))"
                ) -> ${seconds_to_sleep}s"
    sleep "${seconds_to_sleep}"
    return 1
}


###############################################################################
#
#   Name          : _check_hddio
#   Parameters    : None
#   Globals       : $HDDIO_RATE   : Rate in kB/s of HDD-IO.
#                 : $P_HDDIO_DEVS : Associative array for storing read, wrtn
#                                   and epoch values.
#   Return        : 0 : If actual value of hddio is lower than the defined
#                       value, ready for shutdown.
#                 : 1 : If actual value of hddio is higher than the defined
#                       value, no shutdown.
#
_check_hddio()
{
    local rvalue=0

    if [ "${DEBUG}" == "true" ]; then
        _log "DEBUG: HDDIO_RATE: ${HDDIO_RATE} kB/s"
    fi

    local epoch_sec="${EPOCHSECONDS}"
    local last_checked_sec=$((epoch_sec - ${P_HDDIO_DEVS["epoch_sec"]:-${epoch_sec}}))

    while read -r omv_hdd omv_asd_hdd_in omv_asd_hdd_out; do
        if [ "${DEBUG}" == "true" ]; then
            _log "DEBUG: ========== Device: ${omv_hdd} =========="
        fi

        if ! mount -l | grep -q "${omv_hdd}"; then
            if [ "${DEBUG}" == "true" ]; then
                _log "DEBUG: Skipping as no mount point"
            fi
            continue
        fi

        if [ "${DEBUG}" == "true" ]; then
            blkid -s LABEL -s UUID | grep "${omv_hdd}" | while read -r line; do
                _log "DEBUG: ${line}"
            done
            _log "DEBUG: Actual: kB_read: ${omv_asd_hdd_in}, kB_wrtn: ${omv_asd_hdd_out}"
        fi

        if [[ "${rvalue}" -eq 1 || "${last_checked_sec}" -eq 0 ||
              -z "${P_HDDIO_DEVS["epoch_sec"]:-}" ||
              -z "${P_HDDIO_DEVS["${omv_hdd}_r"]:-}" ||
              -z "${P_HDDIO_DEVS["${omv_hdd}_w"]:-}" ]]; then
            # Store current value.
            P_HDDIO_DEVS["${omv_hdd}_r"]="${omv_asd_hdd_in}"
            P_HDDIO_DEVS["${omv_hdd}_w"]="${omv_asd_hdd_out}"

            if [ "${DEBUG}" == "true" ]; then
                _log "DEBUG: Store new read/write value for device"
            fi
            continue
        fi

        if [ "${DEBUG}" == "true" ]; then
            _log "DEBUG: Previous: kB_read: ${P_HDDIO_DEVS["${omv_hdd}_r"]}, kB_wrtn: ${P_HDDIO_DEVS["${omv_hdd}_w"]}"
        fi

        # Calculate threshold limit (defined kB/s multiplied with second since
        # last checked) to get the total value of kB over the 'last checked
        # time' - 'time now'.
        local hddio_increase=$((HDDIO_RATE * last_checked_sec))

        # Calculate the total value.
        local t_hddio_read=$((P_HDDIO_DEVS["${omv_hdd}_r"] + hddio_increase))
        local t_hddio_write=$((P_HDDIO_DEVS["${omv_hdd}_w"] + hddio_increase))

        # Calculate difference between the last and the actual value.
        local diff_hddio_read=$((omv_asd_hdd_in - P_HDDIO_DEVS["${omv_hdd}_r"]))
        local diff_hddio_write=$((omv_asd_hdd_out - P_HDDIO_DEVS["${omv_hdd}_w"]))

        # Calculate hddio-rate in kB/s - format xx.x.
        local last_hddio_read_rate
        last_hddio_read_rate="$(awk '{printf("%.1f",($1/$2))}' <<< "${diff_hddio_read} ${last_checked_sec}")"
        local last_hddio_write_rate
        last_hddio_write_rate="$(awk '{printf("%.1f",($1/$2))}' <<< "${diff_hddio_write} ${last_checked_sec}")"

        if [ "${DEBUG}" == "true" ]; then
            _log "DEBUG: last_checked_sec: ${last_checked_sec}"
            _log "DEBUG: hddio_increase: ${hddio_increase}"
            _log "DEBUG: t_hddio_read: ${t_hddio_read}"
            _log "DEBUG: diff_hddio_read: ${diff_hddio_read}"
            _log "DEBUG: t_hddio_write: ${t_hddio_write}"
            _log "DEBUG: diff_hddio_write: ${diff_hddio_write}"
            _log "DEBUG: Check: 'omv_asd_hdd_in: ${omv_asd_hdd_in}' <= 't_hddio_read: ${t_hddio_read}'"
            _log "DEBUG: Check: 'omv_asd_hdd_out: ${omv_asd_hdd_out}' <= 't_hddio_write: ${t_hddio_write}'"
        fi

        # Store current value.
        P_HDDIO_DEVS["${omv_hdd}_r"]="${omv_asd_hdd_in}"
        P_HDDIO_DEVS["${omv_hdd}_w"]="${omv_asd_hdd_out}"

        local msg="INFO: Device: ${omv_hdd} (last ${last_checked_sec}s) "
              msg+="kB_read/s: ${last_hddio_read_rate}, "
              msg+="kB_wrtn/s: ${last_hddio_write_rate}"

        if [[ "${omv_asd_hdd_in}" -gt "${t_hddio_read}" ||
              "${omv_asd_hdd_out}" -gt "${t_hddio_write}" ]]; then
            _log "${msg} over: ${HDDIO_RATE} kB/s -> no shutdown"
            rvalue=1
        else
            _log "${msg} under: ${HDDIO_RATE} kB/s -> next check"
        fi

    done < <(iostat -kdyNz | awk 'NR>3 && !/^$/{print $1 " " $5 " " $6}')

    P_HDDIO_DEVS["epoch_sec"]="${epoch_sec}"

    if [ "${DEBUG}" == "true" ]; then _log "DEBUG: rvalue: ${rvalue}"; fi

    _log "INFO: All checks complete"

    return "${rvalue}"
}


###############################################################################
#
#   Name          : _check_config
#   Parameters    : None
#   Globals       : $CONFIG    : The autoshutdown configuration.
#                 : $*         : All options as defined in $CONFIG for
#                                validation.
#                 : $DEFAULT_* : All options as defined in $DEFAULT_CONFIG for
#                                default value reset in case of error.
#   Return        : 0 on success.
#
_check_config()
{
    ## Check Parameters from Config and setting default variables.
    _log "INFO: ------------------------------------------------------"
    _log "INFO: Checking config: ${CONFIG}"

    [[ "${ENABLE}" == "true" || "${ENABLE}" == "false" ]] || {
        _log "WARNING: ENABLE not set properly. It has to be 'true' or 'false'"
        _log "ERR: Exiting ..."
        exit 1; }

    [[ "${FAKE}" == "true" || "${FAKE}" == "false" ]] || {
        _log "WARNING: FAKE not set properly. It has to be 'true' or 'false'"
        _log "WARNING: Set FAKE to true -> Test-mode with VERBOSE true"
        FAKE="true"
        VERBOSE="true"
        DEBUG="true"; }

    # Flag: 1 - 999 (cycles).
    [[ "${CYCLES}" =~ ^([1-9]|[1-9][0-9]|[1-9][0-9]{2})$ ]] || {
        _log "WARNING: Invalid parameter format: Flag"
        _log "WARNING: You set it to '${CYCLES}', which is not the correct syntax. Only '1' - '999' is allowed"
        _log "WARNING: Setting CYCLES to default: ${DEFAULT_CYCLES}"
        CYCLES="${DEFAULT_CYCLES}"; }

    [[ "${PLUGINCHECK}" == "true" || "${PLUGINCHECK}" == "false" ]] || {
            _log "WARNING: AUTOUNRARCHECK not set properly. It has to be 'true' or 'false'"
            _log "WARNING: Set PLUGINCHECK to default: ${DEFAULT_PLUGINCHECK}"
            PLUGINCHECK="${DEFAULT_PLUGINCHECK}"; }

    # CheckClockActive together with UPHOURS.
    [[ "${CHECKCLOCKACTIVE}" == "true" || "${CHECKCLOCKACTIVE}" == "false" ]] || {
        _log "WARNING: CHECKCLOCKACTIVE not set properly. It has to be 'true' or 'false'"
        _log "WARNING: Set CHECKCLOCKACTIVE to default: ${DEFAULT_CHECKCLOCKACTIVE}"
        CHECKCLOCKACTIVE="${DEFAULT_CHECKCLOCKACTIVE}"; }

    if [ "${CHECKCLOCKACTIVE}" == "true" ]; then
        [[ "${UPHOURS}" =~ ^((([0-1]?[0-9]|[2][0-3])((:[0-5][0-9])?)).{2}(([0-1]?[0-9]|[2][0-3])((:[0-5][0-9])?)))$ &&
           "${BASH_REMATCH[1]}" != "${BASH_REMATCH[2]}" ]] || {
            _log "WARNING: Invalid parameter list format: UPHOURS [hour1..hour2] and hour1 != hour2"
            _log "WARNING: You set it to '${UPHOURS}', which is not the correct syntax. Maybe it's empty?"
            _log "WARNING: Setting UPHOURS to default: ${DEFAULT_UPHOURS}"
            UPHOURS="${DEFAULT_UPHOURS}"; }
    else
        _log "WARNING: CHECKCLOCKACTIVE is set to false"
        _log "WARNING: Ignoring UPHOURS"
    fi

    [[ "${CHECKPROCNAMES}" == "true" || "${CHECKPROCNAMES}" == "false" ]] || {
        _log "WARNING: CHECKPROCNAMES not set properly. It has to be 'true' or 'false'"
        _log "WARNING: Set CHECKPROCNAMES to default: ${DEFAULT_CHECKPROCNAMES}"
        CHECKPROCNAMES="${DEFAULT_CHECKPROCNAMES}"; }

    if [ "${CHECKPROCNAMES}" == "true" ]; then
        local -r regex="^([A-Za-z0-9_.-]+)+(,[A-Za-z0-9_.-]+)*$"

        if [ "${LOADPROCNAMES}" == "-" ]; then
            _log "INFO: LOADPROCNAMES is disabled - No load processes being checked"
            LOADPROCNAMES=""
        elif [ -z "${LOADPROCNAMES}" ]; then
            _log "INFO: LOADPROCNAMES is set to default: ${DEFAULT_LOADPROCNAMES}"
            LOADPROCNAMES="${DEFAULT_LOADPROCNAMES}"
        elif [[ ! "${LOADPROCNAMES}" =~ ${regex} ]]; then
            _log "WARNING: Invalid parameter list format: LOADPROCNAMES [lproc1,lproc2,lproc3,...]"
            _log "WARNING: You set it to '${LOADPROCNAMES}', which is not the correct syntax"
            _log "ERR: Exiting ..."
            exit 1
        fi

        if [ "${TEMPPROCNAMES}" == "-" ]; then
            _log "INFO: TEMPPROCNAMES is disabled - No temp processes being checked"
            TEMPPROCNAMES=""
        elif  [ -z "${TEMPPROCNAMES}" ]; then
            _log "INFO: TEMPPROCNAMES is set to default: ${DEFAULT_TEMPPROCNAMES}"
            TEMPPROCNAMES="${DEFAULT_TEMPPROCNAMES}"
        elif [[ ! "${TEMPPROCNAMES}" =~ ${regex} ]]; then
            _log "WARNING: Invalid parameter list format: TEMPPROCNAMES [tproc1,tproc2,tproc3,...]"
            _log "WARNING: You set it to '${TEMPPROCNAMES}', which is not the correct syntax"
            _log "ERR: Exiting ..."
            exit 1
        fi
    else
        _log "WARNING: CHECKPROCNAMES is set to false"
        _log "WARNING: Ignoring CHECKPROCNAMES and TEMPPROCNAMES"
    fi

    [[ "${CHECKSOCKETS}" == "true" || "${CHECKSOCKETS}" == "false" ]] || {
        _log "WARNING: CHECKSOCKETS not set properly. It has to be 'true' or 'false'"
        _log "WARNING: Set CHECKSOCKETS to default: ${DEFAULT_CHECKSOCKETS}"
        CHECKSOCKETS="${DEFAULT_CHECKSOCKETS}"; }

    # Port-Numbers with at least 2 digits.
    if [ "${CHECKSOCKETS}" == "true" ]; then
        [[ "${NSOCKETNUMBERS}" =~ ^([0-9]{2,5})+(,[0-9]{2,5})*$ ]] || {
            _log "WARNING: Invalid parameter list format: NSOCKETNUMBERS [nsocket1,nsocket2,nsocket3,...]"
            _log "WARNING: Only Port-Numbers with at least 2 digits are allowed"
            _log "WARNING: You set it to '${NSOCKETNUMBERS}', which is not the correct syntax. Maybe it's empty?"
            _log "WARNING: Setting NSOCKETNUMBERS to default: ${DEFAULT_NSOCKETNUMBERS}"
            NSOCKETNUMBERS="${DEFAULT_NSOCKETNUMBERS}"; }
    else
        _log "WARNING: CHECKSOCKETS is set to false"
        _log "WARNING: Ignoring NSOCKETNUMBERS"
    fi

    if [[ "${CHECKSOCKETS}" == "true" && -n "${NSOCKETIGNORESELF:-}" ]]; then
        [[ "${NSOCKETIGNORESELF}" == "true" ||
           "${NSOCKETIGNORESELF}" == "false" ]] || {
            _log "WARNING: NSOCKETIGNORESELF not set properly. It has to be 'true' or 'false'"
            _log "WARNING: Set NSOCKETIGNORESELF to default: ${DEFAULT_NSOCKETIGNORESELF}"
            NSOCKETIGNORESELF="${DEFAULT_NSOCKETIGNORESELF}"; }
    fi

    [[ "${IPCHECK}" == "true" || "${IPCHECK}" == "false" ]] || {
        _log "WARNING: IPCHECK not set properly. It has to be 'true' or 'false'"
        _log "WARNING: Set IPCHECK to default: ${DEFAULT_IPCHECK}"
        IPCHECK="${DEFAULT_IPCHECK}"; }

    # PINGLIST OR RANGE set-up.
    if [[ -n "${PINGLIST:-}" && -f "${PINGLIST}" ]]; then
        _log "INFO: PINGLIST is set in the config, reading IPs from: '${PINGLIST}'"
        _log "INFO: Overidding IPCHECK to: 'true'"
        unset RANGE
        IPCHECK="true"
    elif [[ -n "${PINGLIST:-}" && ! -f "${PINGLIST}" ]]; then
        _log "WARNING: PINGLIST is set in the config, but file not found: '${PINGLIST}'"
        _log "WARNING: Set IPCHECK to: 'false'"
        IPCHECK="false"
    elif [ "${IPCHECK}" == "false" ]; then
        _log "WARNING: IPCHECK is set to false"
        _log "WARNING: Ignoring RANGE"
    elif [[ -z "${RANGE:=}" || "${RANGE}" == "-" ]]; then
        _log "WARNING: RANGE is set to '${RANGE}' -> no IP-Check"
        IPCHECK="false"
    elif [[ -n "${RANGE:-}" && ! "${RANGE}" =~ ^(([a-z]+[0-9]+[:])?(([0-9]{1,3}\.){3})?[1-9][0-9]{0,2})?(([a-z]+[0-9]+[:])?(([0-9]{1,3}\.){3})?[1-9][0-9]{0,2}\.{2}[1-9][0-9]{0,2})?(,(([a-z]+[0-9]+[:])?(([0-9]{1,3}\.){3})?[1-9][0-9]{0,2})|(([a-z]+[0-9]+[:])?(([0-9]{1,3}\.){3})?[1-9][0-9]{0,2}\.{2}[1-9][0-9]{0,2}))*$ ]]; then
        _log "WARNING: Invalid parameter list format: ${RANGE}"
        _log "WARNING: The 'RANGE' should be comma delimited list of the following:"
        _log "WARNING: Define an IP range: start..end | iface:start..end | www.xxx.yyy.start..end | iface:xxx.yyy.zzz.start..end"
        _log "WARNING: Define a single IP: Last octet of IP zzz | www.xxx.yyy.zzz | iface:www.xxx.yyy.zzz"
        _log "WARNING: If 'start..end' or 'Last octet of IP' is set the first three octets of the iface IP address are used"
        _log "WARNING: Setting RANGE to default: ${DEFAULT_RANGE}"
        RANGE="${DEFAULT_RANGE}"
    fi

    [[ "${HDDIOCHECK}" == "true" || "${HDDIOCHECK}" == "false" ]] || {
        _log "WARNING: HDDIOCHECK not set properly. It has to be 'true' or 'false'"
        _log "WARNING: Set HDDIOCHECK to default: ${DEFAULT_HDDIOCHECK}"
        HDDIOCHECK="${DEFAULT_HDDIOCHECK}"; }

    # HDDIO_RATE (max 6 digits -> 1 - 999999 kB/s).
    if [ "${HDDIOCHECK}" == "true" ]; then
        [[ "${HDDIO_RATE}" =~ ^([1-9]|[1-9][0-9]{1,5})$ ]] || {
            _log "WARNING: Invalid parameter format: HDDIO_RATE"
            _log "WARNING: You set it to '${HDDIO_RATE}', which is not the correct syntax. Maybe it's empty?"
            _log "WARNING: Set HDDIO_RATE to default: ${DEFAULT_HDDIO_RATE}"
            HDDIO_RATE="${DEFAULT_HDDIO_RATE}"; }
    else
        _log "WARNING: HDDIOCHECK is set to false"
        _log "WARNING: Ignoring HDDIO_RATE"
    fi

    # Sleep: 1 - 9999.
    [[ "${SLEEP}" =~ ^([1-9]|[1-9][0-9]{1,3})$ ]] || {
        _log "WARNING: Invalid parameter format: SLEEP (sec)"
        _log "WARNING: You set it to '${SLEEP}', which is not the correct syntax"
        _log "WARNING: Only '1' - '9999' is allowed. Maybe it's empty?"
        _log "WARNING: Setting SLEEP to default: ${DEFAULT_SLEEP}"
        SLEEP="${DEFAULT_SLEEP}"; }

    [[ "${ULDLCHECK}" == "true" || "${ULDLCHECK}" == "false" ]] || {
        _log "WARNING: ULDLCHECK not set properly. It has to be 'true' or 'false'"
        _log "WARNING: Set ULDLCHECK to default: ${DEFAULT_ULDLCHECK}"
        ULDLCHECK="${DEFAULT_ULDLCHECK}"; }

    # ULDLRATE (max 6 digits -> 1 - 999999 kB/s).
    if [ "${ULDLCHECK}" == "true" ]; then
        [[ "${ULDLRATE}" =~ ^([1-9]|[1-9][0-9]{1,5})$ ]] || {
            _log "WARNING: Invalid parameter format: ULDLRATE"
            _log "WARNING: You set it to '${ULDLRATE}', which is not the correct syntax. Maybe it's empty?"
            _log "WARNING: Set ULDLRATE to default: ${DEFAULT_ULDLRATE}"
            ULDLRATE="${DEFAULT_ULDLRATE}"; }
    else
        _log "WARNING: ULDLCHECK is set to false"
        _log "WARNING: Ignoring ULDLRATE"
    fi

    [[ "${LOADAVERAGECHECK}" == "true" || "${LOADAVERAGECHECK}" == "false" ]] || {
        _log "WARNING: LOADAVERAGECHECK not set properly. It has to be 'true' or 'false'"
        _log "WARNING: Set LOADAVERAGECHECK to default: ${DEFAULT_LOADAVERAGECHECK}"
        LOADAVERAGECHECK="${DEFAULT_LOADAVERAGECHECK}"; }

    # LOADAVERAGE (max 3 digits).
    if [ "${LOADAVERAGECHECK}" == "true" ]; then
        [[ "${LOADAVERAGE}" =~ ^([1-9]|[1-9][0-9]{1,2})$ ]] || {
            _log "WARNING: Invalid parameter format: LOADAVERAGE"
            _log "WARNING: You set it to '${LOADAVERAGE}', which is not the correct syntax. Maybe it's empty?"
            _log "WARNING: Set LOADAVERAGECHECK to default: ${DEFAULT_LOADAVERAGE}"
            LOADAVERAGE="${DEFAULT_LOADAVERAGE}"; }
    else
        _log "WARNING: LOADAVERAGECHECK is set to false"
        _log "WARNING: Ignoring LOADAVERAGE"
    fi

    # SHUTDOWNCOMMAND - Check acpi power states with pm-is-supported.
    # Thx to http://wiki.ubuntuusers.de/pm-utils.
    _log "INFO: SHUTDOWNCOMMAND is set to: ${SHUTDOWNCOMMAND}"
    # Check power management modes.
    _log "INFO: Your Kernel supports the following modes from pm-utils:"
    local pm_suspend="false"
    pm-is-supported --suspend && {
         _log "INFO: Kernel supports: SUSPEND (SUSPEND to RAM)"
        pm_suspend="true"; }

    local pm_hibernate="false"
    pm-is-supported --hibernate && {
        _log "INFO: Kernel supports: HIBERNATE (SUSPEND to DISK)"
        pm_hibernate="true"; }

    local pm_suspend_hybrid="false"
    pm-is-supported --suspend-hybrid && {
        _log "INFO: Kernel supports: HYBRID-SUSPEND (to DISK & to RAM)"
        pm_suspend_hybrid="true"; }

    # Check, if pm-suspend is supported.
    if [[ "${SHUTDOWNCOMMAND}" == "pm-suspend" &&
          "${pm_suspend}" == "false" ]]; then
        _log "WARNING: You set 'SHUTDOWNCOMMAND=\"pm-suspend\"', but your PC doesn't support this!"
        _log "WARNING: Setting it to default: ${DEFAULT_SHUTDOWNCOMMAND}"
        SHUTDOWNCOMMAND="${DEFAULT_SHUTDOWNCOMMAND}"
    # Check, if pm-hibernate is supported.
    elif [[ "${SHUTDOWNCOMMAND}" == "pm-hibernate" &&
            "${pm_hibernate}" == "false" ]]; then
        _log "WARNING: You set 'SHUTDOWNCOMMAND=\"pm-hibernate\"', but your PC doesn't support this!"
        _log "WARNING: Setting it to default: ${DEFAULT_SHUTDOWNCOMMAND}"
        SHUTDOWNCOMMAND="${DEFAULT_SHUTDOWNCOMMAND}"
    # Check, if pm-suspend-hybrid is supported.
    elif [[ "${SHUTDOWNCOMMAND}" == "pm-suspend-hybrid" &&
            "${pm_suspend_hybrid}" == "false" ]]; then
        _log "WARNING: You set 'SHUTDOWNCOMMAND=\"pm-suspend-hybrid\"', but your PC doesn't support this!"
        _log "WARNING: Setting it to default: ${DEFAULT_SHUTDOWNCOMMAND}"
        SHUTDOWNCOMMAND="${DEFAULT_SHUTDOWNCOMMAND}"
    fi

    return 0
}


###############################################################################
#
#   Name          : _check_networkconfig
#   Parameters    : None
#   Globals       : $FORCE_NIC : Force network interface lookup make sure you
#                                insert a comma or space between each network
#                                interface to be checked.
#                 : $NIC_TO_IP : Associative array for storing network
#                                interface to IP address mappings.
#   Return        : 0 on success.
#
_check_networkconfig()
{
    _log "INFO: ------------------------------------------------------"
    _log "INFO: Finding up network interfaces and associated IPv4 address"

    local -r net_ifaces="${FORCE_NIC:-"en,eth,wlan,bond,usb"}"
    while read -r net_iface ip; do
        local operstate
        operstate="$(< "/sys/class/net/${net_iface}/operstate")"
        local ipv4_valid=0
        [[ "${ip}" =~ ^((25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])\.){3}(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])$ ]] ||
            ipv4_valid=1

        if [ "${DEBUG}" == "true" ]; then
            _log "DEBUG: Network interfaces: ${net_iface}"
            _log "DEBUG: Network interfaces status: ${operstate}"
            _log "DEBUG: Network interfaces IPv4 address: ${ip}"
            _log "DEBUG: Network interfaces IPv4 address valid: ${ipv4_valid}"
        fi

        [ "${ipv4_valid}" -eq 0 ] &&
            [ "${operstate}" != "down" ] && {
                _log "INFO: '${net_iface}' has IPv4 address: ${ip}"
                NIC_TO_IP["${net_iface}"]="${ip}"; }

    done < <(LC_ALL=C ip -o -4 address show |
                awk -F"/| " -v regex=": ${net_ifaces//[, ]/|: }" \
                    '$0 ~ regex {print $2 " " $7}')

    [ -z "${!NIC_TO_IP[*]}" ] && {
        _log "ERR: No valid network interface found, exiting ..."
        exit 1; }

    return 0
}


###############################################################################
#
#   Name          : _check_system_active
#   Parameters    : None
#   Globals       : $*         : All options as defined in $CONFIG for
#                                validation.
#                 : $NIC_TO_IP : Associative array for storing network
#                                interface to IP address mappings.
#   Return        : 0 : If no active host has been found.
#                 : 1 : If at least one active host has been found, no
#                       shutdown.
#
_check_system_active()
{
    # PRIO 0: Do a check, if the actual time is within the range of defined
    # STAYUP-phase for this system e.g. 06:00 - 20:00, stay up, otherwise
    # shutdown.
    if [ "${CHECKCLOCKACTIVE}" == "true" ]; then
        if [ "${DEBUG}" == "true" ]; then
            _log "DEBUG: Calling: _check_clock()"
        fi
        _check_clock || true
    fi

    for net_iface in "${!NIC_TO_IP[@]}"; do
        if [ "${DEBUG}" == "true" ]; then
            _log "DEBUG: Running on: ${net_iface}"
        fi

        # PRIO 1: Ping each IP address in parameter list every network
        # interface should be checked.
        if [ "${IPCHECK}" == "true" ]; then
            if [ "${DEBUG}" == "true" ]; then
                _log "DEBUG: Calling: _ping_range()"
            fi
            _ping_range "${net_iface}" \
                        "${NIC_TO_IP["${net_iface}"]}" \
                        "${NIC_TO_IP[*]}" || return 1
        fi

        # PRIO 2: Do a check for active network sockets.
        if [ "${CHECKSOCKETS}" == "true" ]; then
            if [ "${DEBUG}" == "true" ]; then
                _log "DEBUG: Calling: _check_net_status()"
            fi
            _check_net_status "${net_iface}" "${NIC_TO_IP["${net_iface}"]}" ||
                return 1
        fi
    done

    # PRIO 2: Do a check docker sockets for active network sockets.
    if [ "${CHECKSOCKETS}" == "true" ]; then
        if [ "${DEBUG}" == "true" ]; then
            _log "DEBUG: Calling: _check_docker_status()"
        fi
        _check_docker_status || return 1
    fi

    # PRIO 2: Check for connected users on the CLI.
    if [ "${CHECK_CLI}" == "true" ]; then
        if [ "${DEBUG}" == "true" ]; then
            _log "DEBUG: Calling: _check_users_cli_status()"
        fi
        _check_users_cli_status || return 1
    fi

    # PRIO 2: Check Samba for connected clients.
    if [ "${CHECK_SAMBA}" == "true" ]; then
        if [ "${DEBUG}" == "true" ]; then
            _log "DEBUG: Calling: _check_smb_status()"
        fi
        _check_smb_status || return 1
    fi

    for net_iface in "${!NIC_TO_IP[@]}"; do
        # PRIO 3: Do a check for ul-dl-rate every network interface should be
        # checked for uldl-rate.
        if [ "${ULDLCHECK}" == "true" ]; then
            if [ "${DEBUG}" == "true" ]; then
                _log "DEBUG: Calling: _check_ul_dl_rate()"
            fi
            _check_ul_dl_rate "${net_iface}" || return 1
        fi
    done

    # PRIO 4: Do a hdd io check.
    if [ "${HDDIOCHECK}" == "true" ]; then
        if [ "${DEBUG}" == "true" ]; then
            _log "DEBUG: Calling: _check_hddio()"
        fi
        _check_hddio || return 1
    fi

    # PRIO 5: Do a check for some active processes.
    if [ "${CHECKPROCNAMES}" == "true" ]; then
        if [ "${DEBUG}" == "true" ]; then
            _log "DEBUG: Calling: _check_processes()"
        fi
        _check_processes || return 1
    fi

    # PRIO 6: Do a load average check.
    if [ "${LOADAVERAGECHECK}" == "true" ]; then
        if [ "${DEBUG}" == "true" ]; then
            _log "DEBUG: Calling: _check_loadaverage()"
        fi
        _check_loadaverage || return 1
    fi

    # PRIO 7: Do a PlugIn-Check for any existing files, setup in plugins.
    if [ "${PLUGINCHECK}" == "true" ]; then
        if [ "${DEBUG}" == "true" ]; then
            _log "DEBUG: Calling: _check_plugin()"
        fi
        _check_plugin || return 1
    fi

    return 0
}


###############################################################
######### Start of body function script autoshutdown ##########
###############################################################
_log "INFO: XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX" force
_log "INFO: XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX" force
_log "INFO: XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX" force
_log "INFO: Openmediavault-autoshutdown version: $(
    dpkg -s openmediavault-autoshutdown | awk '/Version:/{print $2}')" force
_log "INFO: Script md5sum: $(md5sum "${0}" | awk '{print $1}')" force
_log "INFO: Initialize logging to: ${FACILITY}" force

[ ! -f "${CONFIG}" ] && {
    _log "ERR: Config file not found! Please check ${CONFIG} exits ..."
    exit 1; }
. "${CONFIG}"
_log "INFO: ${CONFIG} loaded"

[ ! -f "${DEFAULT_CONFIG}" ] && {
    _log "ERR: Default config file not found! Please check ${DEFAULT_CONFIG} exits ..."
    exit 1; }
. <(awk '$0 !~ /^[ ]*#/ && $0 !~ /^$/{print "DEFAULT_"$0}' "${DEFAULT_CONFIG}")
_log "INFO: ${DEFAULT_CONFIG} loaded"

# Set-up logging and modes.
[ "${FAKE}" == "true" ] && VERBOSE="true"
[ "${VERBOSE}" == "true" ] && DEBUG="true"

_check_config

# Enable / disable check here.
[ "${ENABLE}" == "false" ] && {
    _log "INFO: Script disabled by autoshutdown.conf"
    _log "INFO: Nothing to do. Exiting here ..."
    exit 0; }

_check_networkconfig

if [ "${DEBUG}" == "true" ]; then
    _log "DEBUG: XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX"
    _log "DEBUG: CYCLES: ${CYCLES}"
    _log "DEBUG: SLEEP: ${SLEEP}"
    _log "DEBUG: VERBOSE: ${VERBOSE}"
    _log "DEBUG: FAKE: ${FAKE}"
    _log "DEBUG: SHUTDOWNCOMMAND: ${SHUTDOWNCOMMAND}"
    _log "DEBUG: CHECKCLOCKACTIVE: ${CHECKCLOCKACTIVE}"
    _log "DEBUG: UPHOURS: ${UPHOURS}"
    _log "DEBUG: IPCHECK: ${IPCHECK}"
    _log "DEBUG: RANGE: ${RANGE}"
    _log "DEBUG: CHECKSOCKETS: ${CHECKSOCKETS}"
    _log "DEBUG: NSOCKETNUMBERS: ${NSOCKETNUMBERS}"
    _log "DEBUG: HDDIOCHECK: ${HDDIOCHECK}"
    _log "DEBUG: HDDIO_RATE: ${HDDIO_RATE}"
    _log "DEBUG: ULDLCHECK: ${ULDLCHECK}"
    _log "DEBUG: ULDLRATE: ${ULDLRATE}"
    _log "DEBUG: LOADAVERAGECHECK: ${LOADAVERAGECHECK}"
    _log "DEBUG: LOADAVERAGE: ${LOADAVERAGE}"
    _log "DEBUG: CHECKPROCNAMES: ${CHECKPROCNAMES}"
    _log "DEBUG: LOADPROCNAMES: ${LOADPROCNAMES}"
    _log "DEBUG: TEMPPROCNAMES: ${TEMPPROCNAMES}"
    _log "DEBUG: NSOCKETIGNORESELF: ${NSOCKETIGNORESELF:-"${DEFAULT_NSOCKETIGNORESELF}"}"
    _log "DEBUG: PLUGINCHECK: ${PLUGINCHECK}"
    _log "DEBUG: Plugins found in /etc/autoshutdown.d:"
    for plugin_firstcheck in /etc/autoshutdown.d/*; do
        _log "DEBUG: Plugin: ${plugin_firstcheck}"
    done
fi

_log "INFO: --------------- Initialise states --------------------"

[ "${HDDIOCHECK}" == "true" ] && ! _check_hddio && {
    _log "ERR: Initialising _check_hddio(): Please check using debug mode"
    exit 1; }

for net_iface in "${!NIC_TO_IP[@]}"; do
    [ "${ULDLCHECK}" == "true" ] && ! _check_ul_dl_rate "${net_iface}" && {
        _log "ERR: Initialising _check_ul_dl_rate(): Please check using debug mode"
        exit 1; }
done

_log "INFO: ---------------- Script started ----------------------"
_log "INFO: ${CYCLES} test cycles until shutdown is issued"

if [ "${FAKE}" == "true" ]; then
    _log "INFO: FAKE-Mode in on, waiting 1 second for first check"
    sleep 1
else
    _log "INFO: Waiting 5 minuets until the first check"
    sleep 5m
fi

for net_iface in "${!NIC_TO_IP[@]}"; do
    _log "INFO: Script is doing checks for NIC(s): ${net_iface} - ${NIC_TO_IP[${net_iface}]}"
done

# Initialise the loop counter.
FCNT="${CYCLES}"
while : ; do
    _log "INFO: ------------------------------------------------------"
    _log "INFO: New supervision cycle started - Check system activity"

    # Main loop keep checking _check_system_active, to decide whether we
    # should shutdown or not.
    if _check_system_active; then
        # Nothing found so subtract one from the count and check if we
        # can shutdown yet.
        FCNT=$(( FCNT - 1 ))
        _log "INFO: All system active check passed, ${FCNT} cycles until shutdown..."
        [ "${FCNT}" -eq 0 ] && _shutdown
    else
        # Reset count.
        FCNT="${CYCLES}"
    fi

    # Wait for the required time before checking again.
    _log "INFO: Sleep for ${SLEEP}s"
    sleep "${SLEEP}"
done
